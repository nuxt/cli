import type { ParsedArgs } from 'citty'
import type { ListenOptions } from 'listhen'
import type { NuxtDevContext } from '../dev/utils'

import process from 'node:process'

import { defineCommand } from 'citty'
import { getArgs as getListhenArgs } from 'listhen/cli'
import { resolve } from 'pathe'
import { satisfies } from 'semver'
import { isBun, isTest } from 'std-env'

import { initialize } from '../dev'
import { ForkPool } from '../dev/pool'
import { overrideEnv } from '../utils/env'
import { logger } from '../utils/logger'
import { cwdArgs, dotEnvArgs, envNameArgs, extendsArgs, legacyRootDirArgs, logLevelArgs } from './_shared'

const startTime: number | undefined = Date.now()
const forkSupported = !isTest && (!isBun || isBunForkSupported())
const listhenArgs = getListhenArgs()

const command = defineCommand({
  meta: {
    name: 'dev',
    description: 'Run Nuxt development server',
  },
  args: {
    ...cwdArgs,
    ...logLevelArgs,
    ...dotEnvArgs,
    ...legacyRootDirArgs,
    ...envNameArgs,
    ...extendsArgs,
    clear: {
      type: 'boolean',
      description: 'Clear console on restart',
      default: false,
    },
    fork: {
      type: 'boolean',
      description: forkSupported ? 'Disable forked mode' : 'Enable forked mode',
      negativeDescription: 'Disable forked mode',
      default: forkSupported,
      alias: ['f'],
    },
    ...{
      ...listhenArgs,
      'port': {
        ...listhenArgs.port,
        description: 'Port to listen on (default: `NUXT_PORT || NITRO_PORT || PORT || nuxtOptions.devServer.port`)',
        alias: ['p'],
      },
      'open': {
        ...listhenArgs.open,
        alias: ['o'],
        default: false,
      },
      'host': {
        ...listhenArgs.host,
        alias: ['h'],
        description: 'Host to listen on (default: `NUXT_HOST || NITRO_HOST || HOST || nuxtOptions.devServer?.host`)',
      },
      'clipboard': { ...listhenArgs.clipboard, default: false },
      'https.domains': {
        ...listhenArgs['https.domains'],
        description: 'Comma separated list of domains and IPs, the autogenerated certificate should be valid for (https: true)',
      },
    },
    sslCert: {
      type: 'string',
      description: '(DEPRECATED) Use `--https.cert` instead.',
    },
    sslKey: {
      type: 'string',
      description: '(DEPRECATED) Use `--https.key` instead.',
    },
  },
  async run(ctx) {
    // Prepare
    overrideEnv('development')
    const cwd = resolve(ctx.args.cwd || ctx.args.rootDir)

    const listenOverrides = resolveListenOverrides(ctx.args)

    if (!ctx.args.fork) {
      // No-fork mode: everything runs in-process with direct listening
      const { listener, close } = await initialize({
        cwd,
        args: ctx.args,
      }, {
        data: ctx.data,
        listenOverrides,
        showBanner: true,
      })

      return {
        listener,
        async close() {
          await close()
          await listener.close()
        },
      }
    }

    // Fork mode: use pool of pre-warmed forks
    const pool = new ForkPool({
      rawArgs: ctx.rawArgs,
      poolSize: 2,
      listenOverrides,
    })

    // Start the initial dev server in-process with listener
    const { listener, close, onRestart, onReady } = await initialize({
      cwd,
      args: ctx.args,
    }, {
      data: ctx.data,
      listenOverrides,
      showBanner: true,
    })

    // When ready, start warming up the fork pool
    onReady((_address) => {
      pool.startWarming()
      if (startTime) {
        logger.debug(`Dev server ready for connections in ${Date.now() - startTime}ms`)
      }
    })

    // On hard restart, use a fork from the pool
    let cleanupCurrentFork: (() => void) | undefined

    async function restartWithFork() {
      // Get a fork from the pool (warm if available, cold otherwise)
      const context: NuxtDevContext = {
        cwd,
        args: ctx.args,
      }

      // Clean up previous fork if any
      if (cleanupCurrentFork) {
        cleanupCurrentFork()
      }

      cleanupCurrentFork = await pool.getFork(context, (message) => {
        // Handle IPC messages from the fork
        if (message.type === 'nuxt:internal:dev:ready') {
          if (startTime) {
            logger.debug(`Dev server ready for connections in ${Date.now() - startTime}ms`)
          }
        }
        else if (message.type === 'nuxt:internal:dev:restart') {
          // Fork is requesting another restart
          void restartWithFork()
        }
        else if (message.type === 'nuxt:internal:dev:rejection') {
          logger.info(`Restarting Nuxt due to error: \`${message.message}\``)
          void restartWithFork()
        }
      })
    }

    onRestart(async (devServer) => {
      // Close the in-process dev server
      await Promise.all([
        listener.close(),
        devServer.close().catch(() => {}),
        close(),
      ])

      await restartWithFork()
    })

    return {
      listener,
      async close() {
        cleanupCurrentFork?.()
        await close()
        await listener.close()
      },
    }
  },
})

export default command

// --- Internal ---

type ArgsT = Exclude<
  Awaited<typeof command.args>,
  undefined | ((...args: unknown[]) => unknown)
>

function resolveListenOverrides(args: ParsedArgs<ArgsT>): Partial<ListenOptions> {
  const httpsEnv = resolveHttpsFromEnv()

  const _httpsCert = args['https.cert']
    || (args.sslCert as string)
    || httpsEnv.cert

  const _httpsKey = args['https.key']
    || (args.sslKey as string)
    || httpsEnv.key

  const overrides = {
    ...args,
    'open': (args.o as boolean) || args.open,
    'https': args.https,
    'https.cert': _httpsCert || '',
    'https.key': _httpsKey || '',
    'https.pfx': args['https.pfx'] || '',
    'https.passphrase': args['https.passphrase'] || '',
  }

  // _PORT is used by `@nuxt/test-utils` to launch the dev server on a specific port
  // It takes highest priority over all other port sources
  if (process.env._PORT) {
    return {
      ...overrides,
      port: process.env._PORT || 0,
      hostname: '127.0.0.1',
      showURL: false,
    }
  }

  return overrides
}

// Helper to resolve HTTPS certificate and key from environment variables
function resolveHttpsFromEnv() {
  const cert = process.env.NUXT_SSL_CERT || process.env.NITRO_SSL_CERT || ''
  const key = process.env.NUXT_SSL_KEY || process.env.NITRO_SSL_KEY || ''
  return { cert, key }
}

function isBunForkSupported() {
  const bunVersion: string = (globalThis as any).Bun.version
  return satisfies(bunVersion, '>=1.2')
}
